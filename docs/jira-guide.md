# Jira 티켓 작성 가이드

> 💡 **빠른 참고**가 필요하면 [빠른 참고 섹션](#빠른-참고-가이드)으로 이동하세요.

## 목차

- [빠른 참고 가이드](#빠른-참고-가이드) - 실무용 체크리스트 및 템플릿
- [상세 가이드](#상세-가이드) - 방법론 및 베스트 프랙티스

---

# 빠른 참고 가이드

## 🚀 3분 체크리스트

### Epic 생성 시
- [ ] 제목: `[MVP] {기능명}`
- [ ] 비즈니스 목표 1-2줄
- [ ] 성공 지표 1-2개

### Story 생성 시
- [ ] User Story: `"{역할}로서, {행동}하고 싶다. {이유} 때문이다."`
- [ ] AC (Given-When-Then) 2-3개
- [ ] 우선순위: P0/P1/P2

### Sub-task 생성 시
- [ ] 제목: `[FE/BE] {작업명}`
- [ ] 체크리스트 3-5개
- [ ] 완료 기준 명시

## 📋 티켓 템플릿 (복붙용)

### Story 템플릿

```markdown
## User Story
"{역할}로서, {행동}하고 싶다. {이유} 때문이다."

## Acceptance Criteria

### AC 1: {기능명}
- [ ] Given: {전제 조건}
- [ ] When: {사용자 행동}
- [ ] Then: {시스템 반응}

### AC 2: {기능명}
- [ ] Given: {전제 조건}
- [ ] When: {사용자 행동}
- [ ] Then: {시스템 반응}

## 관련 문서
- PRD:
- Figma:

## Labels
`story`, `p0`, `frontend`, `backend`
```

### Frontend Sub-task 템플릿

```markdown
## 설명
{UI/컴포넌트 설명 1-2줄}

## 세부 작업
- [ ] {컴포넌트/화면} 구현
- [ ] {상태 관리} 처리
- [ ] {API 연동}
- [ ] {에러 처리}

## 의존성
- API: `METHOD /v1/endpoint`
- 디자인: Figma 링크

## 완료 기준
- [ ] 로컬 동작 검증
- [ ] 코드 리뷰 완료
```

### Backend Sub-task 템플릿

```markdown
## 설명
{API/로직 설명 1-2줄}

## 세부 작업
- [ ] API 엔드포인트 구현
- [ ] Request/Response DTO
- [ ] 비즈니스 로직
- [ ] 단위 테스트

## 도메인 모델
- Entity:
- Repository:

## 의존성
- 외부 API:
- 인프라:

## 완료 기준
- [ ] API 테스트 통과
- [ ] 단위 테스트 커버리지 80%+
- [ ] 코드 리뷰 완료
```

## 🔄 PRD → Jira 변환 플로우

```
1. PRD 읽기
   ↓
2. Epic 생성 (MVP 단위)
   - 제목: [MVP] {제품/기능명}
   - 목표: PRD 성공 지표
   ↓
3. Story 생성 (기능별)
   - F1, F2, F3... → 각각 1개 Story
   - User Story & AC 복사
   ↓
4. Sub-task 생성 (기술 분해)
   - [FE] UI/화면별
   - [BE] API/도메인별
   ↓
5. 우선순위 배정
   - MVP 필수 → P0
   - MVP 권장 → P1
   - Nice to have → P2
```

## 💡 빠른 예시

### 로그인 기능 티켓 구조

```
Epic: [MVP] 사용자 인증
└─ Story: 로그인 기능
    ├─ [FE] 로그인 폼 UI (P0, 2SP)
    ├─ [FE] 소셜 로그인 버튼 (P0, 1SP)
    ├─ [BE] 로그인 API (P0, 3SP)
    ├─ [BE] 소셜 로그인 연동 (P0, 5SP)
    └─ [BE] JWT 토큰 발급 (P0, 2SP)
```

## ⚡ 병렬 처리 전략

### 병렬 vs 순차 판단 (3초 체크)

| 체크 항목 | 병렬 가능 ✅ | 순차 필요 ⛔ |
|----------|------------|------------|
| **API 의존** | API 명세 합의됨 | API 구현 기다려야 함 |
| **데이터** | 독립적 데이터 | 같은 테이블/스키마 수정 |
| **리소스** | 다른 팀원 배정 가능 | 같은 사람만 가능 |
| **도메인** | 다른 기능 영역 | 같은 코드 파일 수정 |

### 병렬 처리 티켓 구조 예시

#### FE/BE 병렬 (API 계약 기반)

```
Story: 상품 목록 조회
├─ [BE] 상품 목록 API (우선, 1일) ← API 명세 먼저 작성
│   └─ API 명세서 작성 → FE 개발 시작 가능
├─ [FE] 상품 목록 UI (병렬, 2일) ← Mock 데이터로 개발
└─ [FE] API 연동 (순차, 0.5일) ← BE 완료 후
```

**전략**:
1. BE가 API 명세만 작성 (Request/Response DTO)
2. FE는 Mock 데이터로 UI 병렬 개발
3. BE API 완료되면 FE가 연동

## ⚡ 우선순위 빠른 판단

| 우선순위 | 질문 | 예시 |
|---------|------|------|
| **P0** | 이거 없으면 출시 못함? | 로그인, 결제 |
| **P1** | UX 개선? 사용자 만족도? | 검색 필터, 알림 |
| **P2** | 있으면 좋은데 없어도 됨? | 다크모드, 통계 |

## 🚫 자주하는 실수

❌ **나쁜 예시**
- 제목: "로그인 수정"
- AC: "로그인 되게 하기"
- Sub-task: "코딩"

✅ **좋은 예시**
- 제목: "[FE] 로그인 폼 - 이메일 validation"
- AC: "사용자가 잘못된 이메일 형식 입력 시 '유효한 이메일을 입력하세요' 빨간색 메시지 표시"
- Sub-task: "이메일 정규식 검증, 에러 메시지 컴포넌트, 포커스 아웃 이벤트 처리"

## 📏 적정 크기

| 티켓 유형 | 기간 | Story Points |
|----------|------|--------------|
| Epic | 1-2개월 | - |
| Story | 1-2주 | 3-8 SP |
| Sub-task | 1-3일 | - |

**너무 크면 쪼개세요:**
- Story > 8SP → 분해
- Sub-task > 3일 → 분해

---

# 상세 가이드

## 📋 개요

이 문서는 PRD를 기반으로 체계적인 Jira 티켓을 생성하는 방법론을 제공합니다.

> **활용 방법**: 이 가이드는 스크럼, 칸반 등 다양한 애자일 방법론에 적용 가능하며, 프로젝트 규모와 팀 구성에 맞게 조정하여 사용하세요.

## 🎯 Jira 티켓의 목적

- **작업 추적**: 개발 진행 상황을 투명하게 관리
- **업무 분배**: 팀원별 역할과 책임 명확화
- **일정 관리**: 스프린트와 마일스톤 기반 계획 수립
- **커뮤니케이션**: 요구사항과 구현 상세를 문서화
- **품질 관리**: 인수 조건 기반 완료 기준 설정

## 📊 티켓 계층 구조

Jira는 3단계 계층 구조를 권장합니다:

```
Epic (대규모 기능)
  └─ Story (사용자 관점 기능)
      ├─ Sub-task (Frontend)
      ├─ Sub-task (Backend)
      └─ Sub-task (Design/QA 등)
```

### Epic
- **정의**: 여러 Sprint에 걸쳐 완성되는 대규모 기능 또는 제품 목표
- **범위**: 보통 한 분기 또는 릴리즈 단위
- **예시**: "[MVP] 사용자 인증 시스템", "[Q1] 결제 기능 구현"

### Story
- **정의**: 사용자 관점에서 가치를 제공하는 기능 단위
- **범위**: 1-2주 내 완료 가능한 크기
- **예시**: "사용자가 소셜 로그인을 할 수 있다", "관리자가 대시보드를 조회할 수 있다"

### Sub-task
- **정의**: Story를 기술적으로 분해한 작업 단위
- **범위**: 1-3일 내 완료 가능한 크기
- **분류**: Frontend, Backend, Design, QA, DevOps 등

## ✍️ User Story 작성법

### 표준 포맷
```
"[역할]로서, [행동]하고 싶다. [이유] 때문이다."
```

### 예시
```markdown
**좋은 예시** ✅
"고객으로서, 장바구니에 상품을 추가하고 싶다. 나중에 구매하기 위해서다."
"관리자로서, 월별 매출 리포트를 조회하고 싶다. 비즈니스 성과를 분석하기 위해서다."

**나쁜 예시** ❌
"장바구니 기능을 만든다" (역할과 이유 누락)
"데이터베이스에 상품 테이블을 추가한다" (기술 구현 중심, 사용자 가치 부재)
```

### 작성 원칙
- **독립적**: 다른 Story와 독립적으로 가치 제공
- **협상 가능**: 구현 방법은 개발팀과 협의 가능
- **가치 중심**: 사용자에게 명확한 가치 제공
- **추정 가능**: 팀이 effort를 추정할 수 있는 크기
- **작은 크기**: 1-2 Sprint 내 완료 가능
- **테스트 가능**: 완료 기준이 명확

## ✅ Acceptance Criteria (인수 조건) 작성법

### Given-When-Then 포맷
```markdown
**Given** (전제 조건)
- 사용자가 로그인된 상태
- 장바구니가 비어있지 않음

**When** (사용자 행동)
- 사용자가 "결제하기" 버튼을 클릭

**Then** (시스템 반응)
- [ ] 결제 페이지로 이동한다
- [ ] 장바구니 총액이 표시된다
- [ ] 결제 수단 선택 옵션이 보인다
- [ ] 주문 정보가 세션에 저장된다
```

### 체크리스트 포맷 (간단한 AC)
```markdown
- [ ] 사용자가 이메일 형식으로만 입력 가능
- [ ] 중복 이메일 검증 (서버 사이드)
- [ ] 인증 메일 발송 성공
- [ ] 에러 발생 시 사용자 친화적 메시지 표시
```

### 작성 원칙
- **구체적**: 모호함 없이 명확한 조건
- **측정 가능**: 통과/실패 판단 가능
- **완전성**: 기능의 모든 케이스 포함
- **비기술적**: 비즈니스 관점에서 작성 (가능하면)
- **우선순위**: 필수(MUST) vs 선택(SHOULD) 구분

## 📦 Frontend/Backend Sub-task 분해

### Frontend Sub-task 작성 패턴

```markdown
#### [FE] 로그인 폼 UI 구현
**설명**: 이메일/비밀번호 입력 폼과 로그인 버튼 구현

**세부 작업**:
- [ ] 이메일 입력 필드 (validation 포함)
- [ ] 비밀번호 입력 필드 (show/hide 토글)
- [ ] 로그인 버튼 (로딩 상태 처리)
- [ ] 에러 메시지 표시 영역
- [ ] 소셜 로그인 버튼 (Google, Apple)

**의존성**:
- API: `POST /v1/auth/login`
- API: `POST /v1/auth/social`

**우선순위**: P0
```

### Backend Sub-task 작성 패턴

```markdown
#### [BE] 로그인 API 구현
**설명**: 이메일/비밀번호 기반 인증 API

**세부 작업**:
- [ ] `POST /v1/auth/login` 엔드포인트
- [ ] Request DTO validation
- [ ] 비밀번호 해싱 검증
- [ ] JWT 토큰 발급
- [ ] Refresh Token 저장
- [ ] Rate limiting (5회/분)

**도메인 모델**:
- User Entity
- AuthToken Value Object
- UserRepository

**의존성**:
- JWT 라이브러리 설정
- Redis (Refresh Token 저장)

**우선순위**: P0
```

### 분해 원칙

| 기준 | Frontend | Backend |
|------|----------|---------|
| **단위** | 화면/컴포넌트 단위 | API/도메인 단위 |
| **설명** | UI/UX 상세, 사용자 인터랙션 | API 명세, 비즈니스 로직 |
| **의존성** | API 엔드포인트, 디자인 시스템 | 외부 API, 인프라, 도메인 모델 |
| **완료 기준** | 스토리북/화면 동작 검증 | API 테스트, 단위 테스트 통과 |

## 🎯 우선순위 설정 기준

### P0 (Critical) - MVP 필수
- **정의**: 이것 없이는 출시 불가능
- **범위**: 핵심 사용자 플로우, 비즈니스 크리티컬 기능
- **예시**: 회원가입, 로그인, 결제, 주문 생성

### P1 (High) - MVP 권장
- **정의**: UX 향상, 사용자 만족도 개선
- **범위**: 편의 기능, 에러 처리 개선, 성능 최적화
- **예시**: 검색 필터, 정렬 옵션, 프로필 수정, 푸시 알림

### P2 (Medium) - Post-MVP
- **정의**: Nice to have, 차기 버전에서 구현
- **범위**: 부가 기능, 실험적 기능
- **예시**: 다크모드, 고급 통계, 커스터마이징 옵션

### P3 (Low) - 백로그
- **정의**: 미래 고려사항
- **범위**: 아이디어 수준, 검증 필요
- **예시**: AI 추천, 소셜 기능 확장

## ⚡ 병렬 처리 최적화 전략

### 병렬 처리의 중요성

**문제 상황**:
```
❌ 순차 처리 (비효율)
Week 1: BE 개발 → FE 대기
Week 2: FE 개발 → BE 대기
총 소요: 2주

✅ 병렬 처리 (효율)
Week 1: BE + FE 동시 개발 (API 계약 기반)
총 소요: 1주
```

**효과**:
- 개발 속도 2배 향상
- 팀원 유휴 시간 최소화
- Sprint 목표 달성률 증가

### 병렬 가능 여부 판단 프레임워크

#### 1. API 계약 기반 병렬 (Contract-Driven Development)

**조건**:
- ✅ API 명세가 사전에 합의됨 (Request/Response DTO)
- ✅ FE가 Mock 데이터로 개발 가능
- ✅ BE가 인터페이스 먼저 정의 가능

**프로세스**:
```
1. API 명세 작성 (0.5일)
   └─ Request/Response DTO
   └─ HTTP Status Code
   └─ 에러 케이스

2. FE/BE 병렬 개발 (3일)
   ├─ [FE] Mock 데이터로 UI 구현
   └─ [BE] 실제 로직 구현

3. 통합 (0.5일)
   └─ FE가 Mock → 실제 API 교체
```

#### 2. 도메인 독립성 기반 병렬

**조건**:
- ✅ 다른 도메인/기능 영역
- ✅ 공유 코드/테이블 없음
- ✅ 비즈니스 로직 독립적

**판단 기준**:
| 질문 | 병렬 가능 | 순차 필요 |
|------|----------|----------|
| 같은 DB 테이블 수정? | ❌ | ✅ |
| 같은 서비스 클래스 수정? | ❌ | ✅ |
| 같은 React 컴포넌트 수정? | ❌ | ✅ |
| 독립된 기능 영역? | ✅ | ❌ |

### 의존성 그래프 작성법

**Jira에서 표현**:
```markdown
LAD-100: [공통] API 명세 작성 (P0, 0.5SP)
├─ Blocks: LAD-101, LAD-102
└─ Labels: `blocker`, `p0`

LAD-101: [BE] API 구현 (P0, 3SP)
├─ Blocked by: LAD-100
├─ Blocks: LAD-103
└─ **병렬 가능**: LAD-102

LAD-102: [FE] Mock UI 구현 (P0, 2SP)
├─ Blocked by: LAD-100
├─ Blocks: LAD-103
└─ **병렬 가능**: LAD-101 ⚡

LAD-103: [FE] API 연동 (P0, 0.5SP)
└─ Blocked by: LAD-101, LAD-102
```

### 병렬 처리 안티패턴 (하지 말 것)

#### ❌ 안티패턴 1: API 없이 FE 시작

```markdown
나쁜 예시:
Week 1: FE가 임의로 API 구조 가정하고 개발
Week 2: BE가 다른 구조로 API 개발
Week 3: FE가 전체 수정 (리팩토링 2주)
```

**해결책**: API 계약 먼저 작성

#### ❌ 안티패턴 2: 같은 파일 동시 수정

```markdown
나쁜 예시:
개발자 A: UserService.kt 수정 (로그인)
개발자 B: UserService.kt 수정 (회원가입)
→ Merge Conflict 발생
```

**해결책**: 파일 단위로 작업 분리

### 병렬 처리 성공 체크리스트

Sprint 계획 시 확인:
- [ ] API 계약이 사전에 작성되었는가?
- [ ] 의존성 그래프가 명확한가?
- [ ] Critical Path를 식별했는가?
- [ ] 팀원별 작업 배정이 겹치지 않는가?
- [ ] Mock 데이터 전략이 있는가?
- [ ] 통합 일정이 확보되었는가?

## 📈 티켓 관리 베스트 프랙티스

### DO ✅

1. **명확한 제목**
   - ✅ "[FE] 로그인 폼 - 이메일 validation 구현"
   - ❌ "로그인 수정"

2. **구체적인 AC**
   - ✅ "사용자가 잘못된 이메일 형식 입력 시 '유효한 이메일을 입력하세요' 메시지 표시"
   - ❌ "이메일 검증 추가"

3. **의존성 명시**
   - API 엔드포인트, 선행 작업, 외부 서비스 명시
   - Blocked by: {티켓 번호}

4. **완료 기준 설정**
   - 코드 리뷰, 테스트, QA 검증 기준 명시

5. **정기적 업데이트**
   - 진행 상황, 블로커, 완료율 주기적 업데이트

### DON'T ❌

1. **모호한 설명**
   - ❌ "기능 개선", "버그 수정", "리팩토링"

2. **너무 큰 티켓**
   - Story > 13SP → 분해 필요
   - Sub-task > 3일 → 분해 필요

3. **의존성 무시**
   - FE 작업인데 API 준비 안 됨
   - BE 작업인데 DB 스키마 미정

4. **우선순위 남발**
   - 모든 게 P0면 우선순위가 없는 것

5. **AC 누락**
   - 완료 기준이 없으면 "완료"를 판단할 수 없음

## ❓ FAQ

### Q1: Story와 Task의 차이는?
**A**:
- **Story**: 사용자 관점 가치 제공 단위 (비즈니스 관점)
- **Task/Sub-task**: 기술적 구현 단위 (개발 관점)

Story는 "왜, 무엇"에 집중하고, Task는 "어떻게"에 집중합니다.

### Q2: Story Points는 어떻게 산정하나요?
**A**:
- **피보나치 수열 사용**: 1, 2, 3, 5, 8, 13
- **상대적 추정**: 기준 Story 대비 복잡도
- **팀 합의**: Planning Poker 등 활용
- **재추정**: Sprint 회고 후 Velocity 조정

### Q3: Sub-task는 언제 만드나요?
**A**:
- Story가 너무 클 때 (>8SP)
- 여러 역할이 협업할 때 (FE + BE + Design)
- 병렬 작업이 가능할 때
- 진행 상황을 세밀하게 추적하고 싶을 때

### Q4: 티켓이 너무 많으면?
**A**:
- Epic을 더 큰 단위로 통합
- Sub-task를 Story로 승격 (독립적 가치 제공 시)
- MVP 범위 재검토 (P2 이하는 백로그로)

### Q5: 긴급 버그는 어떻게 처리하나요?
**A**:
- 별도 Bug 티켓 타입 생성
- 우선순위: P0 (Critical), P1 (High)
- Sprint 중간 투입 시 팀 합의 필요
- Sprint Scope 조정 (다른 티켓 연기)

---

## 📝 문서 관리

**관련 문서**:
- PRD 작성 가이드: [how-to-write-prd.md](./how-to-write-prd.md)
- Jira 스킬 명령어: `.claude/commands/jira/`

**변경 이력**:
| 버전 | 날짜 | 변경 내용 |
|------|------|-----------|
| v1.0 | 2026-01-24 | 초안 작성 |
| v1.1 | 2026-01-25 | 문서 분리 (Quick Reference 추가) |
| v2.0 | 2026-01-27 | 문서 통합 (jira-guide.md 단일 파일로 통합) |
